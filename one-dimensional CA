import numpy as np
import random

#my attempt at a generic class
class CellularAutomaton:
    def __init__(self, cells, states, dimension, neighbours, rand):
        self.cells = cells #aantal cellen in het rooster
        self.states = states #number of states that a cell can have
        self.dimension = dimension #dimension of the cellular automaton
        self.neighbours= neighbours #number of neighbours each cell has
        self.rand = rand #randvoorwaarden
        
#I really don't know how to have a generic way to evaluate the CA here
#So I guess for now I'll just have specific methods in the subclasses

class CA1D(CellularAutomaton):
   # where rules is the number of ruleset as a binary number as a string
   def __init__(self,rules,cells, states, dimension, neighbours, rand):
        self.rules = rules
        self.dimension=1
        super().__init__( cells, states, dimension, neighbours, rand)
    
    # generates a 1D grid with random starting states
    def random_firstgen(self):
        grid= grid=np.empty(self.cells,int)
        for i in range(self.cells):
            grid[i]=random.choice(range(0,self.states))
        return grid
    
    # creates a 1D grid with the middle cell(s) being alive, all others dead
    #only works if there are only two states
    def conventional_firstgen(self):
        grid= grid=np.empty(self.cells,int)
        for i in range(self.cells):
            if self.cells%2==0: #if even
                if i == self.cells//2 or i== self.cells//2+1:
                    grid[i-1]=1
                else:
                    grid[i-1]=0
            else:#if uneven
                if i==self.cells//2:
                    grid[i]=1
                else:
                    grid[i]=0
        return grid
    
    #once it's finished this will deal with the values on the edge of the grid
    def voorwaarden(self,grid,new): 
        if self.rand == "static":
            for i in range (self.cells):
                if i==0 or i==self.cells-1:
                    new[i]=grid[i]
        elif self.rand == "periodic": # have to think about this
            for i in range (self.cells):
                pass
        else:
            return False #would be nice to have an error message here
     
    #this will count alive neighbours
    #this only works if there are just 2 states
    #once I have the voorwaarden function this will be implemented here
    #actually nevermind this is so irrelevant for 1 dim CAs
    def alive_neighbours(self,grid,x):
        neighbours=0
        for i in range (x-self.neighbours//2,x+self.neighbours//2+1):
            if i==x:
                    pass
            else:
                neighbours+=grid[i]
                
        return neighbours
        
    #this will show me what kind of neighbourhood I have at point x    
    def neighbourhood(self,grid,x):
            if grid[x]==1:
                if grid[x-1]==1 and grid[x+1]==1:
                    return 0
                elif grid[x-1]==1 and grid[x+1]==0:
                    return 1 
                elif grid[x-1]==0 and grid[x+1]==1:
                    return 4
                else:
                    return 5
            else:
                if grid[x-1]==1 and grid[x+1]==1:
                    return 2
                elif grid[x-1]==1 and grid[x+1]==0:
                    return 3
                elif grid[x-1]== 0 and grid[x+1]==1:
                    return 6
                else:
                    return 7
    
    #this will show me how my 1D, 2-state CA will behave given a specific ruleset
    #grid is here either conventional_firstgen or random_firstgen
    #still only works with static vaues at the edges though
    def computation(self,grid,rounds):
        print(grid)
        new= grid.copy()
        
        if rounds==0:
            print("done")
        else:
            for i in range(self.cells):
                state= grid[i]
               
                if i==0 or i==self.cells-1:
                     new[i]=state
                else:
                    neighbourhood=self.neighbourhood(grid,i)
                    new[i]=int(self.rules[neighbourhood])
                
            print(new)
            return self.computation(new,rounds-1)
